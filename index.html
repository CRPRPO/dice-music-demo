<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dice Music V3 - Single Block Test</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background: black;
    }
    #webcam {
      position: fixed;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      transform: scaleX(-1); /* üîÑ Èè°ÂÉèÂèçËΩâ */
      z-index: 0;
    }
    canvas {
      position: absolute;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 1;
    }
    #overlay {
      position: absolute;
      width: 100vw;
      height: 100vh;
      z-index: 2;
    }
    .music-block {
      width: 100px;
      height: 100px;
      background: #4caf50;
      position: absolute;
      border-radius: 12px;
      text-align: center;
      line-height: 100px;
      font-size: 28px;
      color: white;
      z-index: 3;
    }
    .drop-zone {
      width: 120px;
      height: 120px;
      background: #555;
      border: 2px dashed white;
      border-radius: 10px;
      position: absolute;
      z-index: 2;
    }
  </style>
</head>
<body>
  <video id="webcam" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="overlay">
    <div class="music-block" id="block1" style="top: 100px; left: 100px;">üéµ</div>
    <div class="drop-zone" style="bottom: 80px; left: 20%;"></div>
    <div class="drop-zone" style="bottom: 80px; left: 45%;"></div>
    <div class="drop-zone" style="bottom: 80px; left: 70%;"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>

  <script>
    const video = document.getElementById('webcam');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const block = document.getElementById('block1');
    let dragging = false;
    let currentBlock = null;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // ÂàùÂßãÂåñÊâãÈÉ®ËøΩËπ§
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const camera = new Camera(video, {
      onFrame: async () => await hands.send({ image: video }),
      width: 640,
      height: 480
    });
    camera.start();

    // ÂíåÂº¶ËÅ≤Èü≥
    const synth = new Tone.PolySynth().toDestination();
    const chord = ["C4", "E4", "G4"];

    function onResults(results) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
      const hand = results.multiHandLandmarks[0];
      const landmarks = hand;

      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#0f0', lineWidth: 3 });
      drawLandmarks(ctx, landmarks, { color: '#f00', lineWidth: 2 });

      const x = window.innerWidth - landmarks[9].x * window.innerWidth;
      const y = landmarks[9].y * window.innerHeight;

      const fingerTipY = landmarks[8].y;
      const fingerBaseY = landmarks[6].y;
      const middleTipY = landmarks[12].y;
      const middleBaseY = landmarks[10].y;

      const rect = block.getBoundingClientRect();
      const inside = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;

      const isFist = fingerTipY > fingerBaseY && middleTipY > middleBaseY;
      const isFingerTap = fingerTipY < fingerBaseY;

      if (inside && isFingerTap && !dragging) {
        Tone.start();
        synth.triggerAttackRelease(chord, '8n');
      }

      if (inside && !dragging && !isFist) {
        dragging = true;
        currentBlock = block;
      }

      if (dragging && currentBlock) {
        currentBlock.style.left = `${x - currentBlock.offsetWidth / 2}px`;
        currentBlock.style.top = `${y - currentBlock.offsetHeight / 2}px`;
      }

      if (dragging && isFist) {
        dragging = false;
        checkDrop(currentBlock);
        currentBlock = null;
      }
    }

    function checkDrop(block) {
      const rect = block.getBoundingClientRect();
      document.querySelectorAll('.drop-zone').forEach(zone => {
        const zoneRect = zone.getBoundingClientRect();
        const hit = !(rect.right < zoneRect.left || rect.left > zoneRect.right || rect.bottom < zoneRect.top || rect.top > zoneRect.bottom);
        if (hit) {
          Tone.start();
          synth.triggerAttackRelease(chord, '2n');
          zone.style.borderColor = '#4caf50';
          setTimeout(() => zone.style.borderColor = 'white', 300);
        }
      });
    }
  </script>
</body>
</html>
